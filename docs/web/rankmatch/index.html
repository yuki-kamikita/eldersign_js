<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="color-scheme" content="light dark" />
    <title>ランクマッチ集計</title>
    <link rel="stylesheet" href="../../theme.css" />
    <style>
      .toolbar {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        justify-content: space-between;
        gap: 16px;
        margin-top: 12px;
      }

      .sticky-controls {
        position: sticky;
        top: 0;
        z-index: 20;
        margin-top: 16px;
        padding: 10px 12px;
        border-radius: 16px;
        background: color-mix(in srgb, var(--md-sys-surface) 88%, transparent);
        backdrop-filter: blur(6px);
        box-shadow: 0 8px 18px var(--md-sys-shadow);
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        justify-content: space-between;
        gap: 16px;
      }

      .search-box {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 8px;
        padding: 6px 12px;
        border-radius: 999px;
        border: 1px solid var(--md-sys-outline-variant);
        background: var(--md-sys-surface);
      }

      .search-label {
        font-size: 0.85rem;
        color: var(--md-sys-on-surface-variant);
      }

      .search-input {
        border: none;
        background: transparent;
        color: var(--md-sys-on-surface);
        font-size: 0.95rem;
        min-width: 260px;
        outline: none;
      }

      .phase-tabs {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
      }

      .phase-controls {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 10px;
      }

      .phase-jump {
        display: flex;
        align-items: center;
        gap: 6px;
        padding: 4px 10px;
        border-radius: 999px;
        border: 1px solid var(--md-sys-outline-variant);
        background: var(--md-sys-surface);
      }

      .phase-jump-label {
        font-size: 0.8rem;
        color: var(--md-sys-on-surface-variant);
      }

      .phase-jump-input {
        width: 72px;
        border: none;
        background: transparent;
        color: var(--md-sys-on-surface);
        font-size: 0.9rem;
        outline: none;
        text-align: right;
      }

      .phase-jump-button {
        border: none;
        background: var(--md-sys-primary);
        color: var(--md-sys-on-primary);
        border-radius: 999px;
        padding: 4px 10px;
        font-size: 0.8rem;
        cursor: pointer;
      }

      .phase-status {
        font-size: 0.85rem;
        color: var(--md-sys-on-surface-variant);
      }

      .phase-button {
        border: 1px solid var(--md-sys-outline-variant);
        background: var(--md-sys-surface);
        color: var(--md-sys-on-surface);
        padding: 8px 16px;
        border-radius: 999px;
        cursor: pointer;
        font-weight: 600;
        transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
      }

      .phase-button.is-active {
        background: var(--md-sys-primary);
        color: var(--md-sys-on-primary);
        border-color: transparent;
        box-shadow: 0 10px 18px var(--md-sys-shadow);
      }

      .phase-button:hover {
        transform: translateY(-2px);
      }

      .helper-note {
        margin: 0;
        color: var(--md-sys-on-surface-variant);
        font-size: 0.95rem;
      }

      .group-grid {
        display: grid;
        gap: 18px;
        grid-template-columns: 1fr;
        margin-top: 24px;
      }

      .group-card {
        padding: 18px;
        border-radius: 20px;
        background: color-mix(in srgb, var(--md-sys-surface) 80%, var(--md-sys-primary-container));
        border: 1px solid var(--md-sys-outline-variant);
        box-shadow: 0 10px 25px var(--md-sys-shadow);
        display: grid;
        gap: 16px;
      }

      .group-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
      }

      .group-actions {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .download-button {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 6px 12px;
        border-radius: 999px;
        border: 1px solid var(--md-sys-outline-variant);
        background: var(--md-sys-surface);
        color: var(--md-sys-on-surface);
        font-size: 0.85rem;
        font-weight: 600;
        text-decoration: none;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }

      .download-button:hover {
        transform: translateY(-2px);
        box-shadow: 0 10px 18px var(--md-sys-shadow);
        text-decoration: none;
      }

      .download-button.is-disabled {
        pointer-events: none;
        opacity: 0.5;
      }

      .group-title {
        margin: 0;
        font-size: 1.1rem;
      }

      .player-list {
        display: grid;
        gap: 14px;
      }

      .player-card {
        border-radius: 16px;
        border: 1px solid var(--md-sys-outline-variant);
        background: var(--md-sys-surface);
        padding: 12px 14px;
        display: grid;
        gap: 10px;
      }

      .player-header {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
      }

      .player-name {
        margin: 0;
        font-size: 1rem;
      }

      .search-link {
        border: none;
        background: none;
        color: inherit;
        padding: 0;
        margin: 0;
        cursor: pointer;
        font: inherit;
        text-align: left;
      }

      .search-link:hover {
        color: var(--md-sys-primary);
      }

      .image-button {
        border: none;
        background: none;
        padding: 0;
        cursor: pointer;
      }

      table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.85rem;
      }

      th,
      td {
        text-align: left;
        padding: 8px 6px;
        border-bottom: 1px solid var(--md-sys-outline-variant);
        vertical-align: top;
      }

      tbody tr:last-child td {
        border-bottom: none;
      }

      th {
        font-weight: 600;
        color: var(--md-sys-on-surface-variant);
        font-size: 0.8rem;
      }

      th.is-toggle {
        cursor: pointer;
      }

      th.is-toggle:hover {
        color: var(--md-sys-primary);
      }

      .image-cell {
        width: 56px;
      }

      .image-cell img {
        width: 48px;
        height: 48px;
        object-fit: contain;
        border: 1px solid var(--md-sys-outline-variant);
        background: var(--md-sys-surface-variant);
      }

      .skill-cell {
        min-width: 180px;
      }

      .skill-list {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
      }

      .skill-tag {
        border: 1px solid var(--md-sys-outline-variant);
        background: var(--md-sys-surface);
        color: var(--md-sys-on-surface);
        border-radius: 999px;
        padding: 2px 8px;
        font-size: 0.75rem;
        cursor: pointer;
      }

      .skill-tag:hover {
        border-color: var(--md-sys-primary);
        color: var(--md-sys-primary);
      }

      .variant-cell {
        white-space: nowrap;
      }

      details summary {
        cursor: pointer;
        color: var(--md-sys-primary);
        font-weight: 600;
        list-style: none;
      }

      details summary::-webkit-details-marker {
        display: none;
      }

      .appear-toggle summary {
        display: inline-flex;
        align-items: center;
        padding: 4px 10px;
        border-radius: 999px;
        background: var(--md-sys-secondary-container);
        color: var(--md-sys-on-secondary-container);
        font-size: 0.8rem;
      }

      .link-list {
        display: grid;
        gap: 6px;
        margin-top: 6px;
      }

      .empty {
        padding: 16px;
        border-radius: 14px;
        border: 1px dashed var(--md-sys-outline);
        color: var(--md-sys-on-surface-variant);
        text-align: center;
        background: color-mix(in srgb, var(--md-sys-surface) 90%, var(--md-sys-primary-container));
        font-size: 0.9rem;
      }

      @media (max-width: 800px) {
        .search-box {
          width: 100%;
        }

        .search-input {
          min-width: 160px;
          flex: 1;
        }

        table {
          font-size: 0.8rem;
        }
      }
    </style>
  </head>
  <body>
    <main>
      <header class="reveal">
        <p class="subtitle">Rankmatch Skill List</p>
        <h1>ランクマッチ集計</h1>
        <p class="helper-note">
          計測結果は自動集計したものです。誤りや漏れがある可能性があります。<br>
          コンパニオンのAスキルは現在未対応です。
        </p>
        <div class="toolbar">
          <a class="button secondary" href="../../index.html">ツール集へ戻る</a>
        </div>
      </header>

      <div class="sticky-controls" id="stickyControls">
        <div class="phase-controls">
          <div class="phase-tabs" id="phaseTabs"></div>
          <form class="phase-jump" id="phaseJumpForm">
            <span class="phase-jump-label">期</span>
            <input
              id="phaseJumpInput"
              class="phase-jump-input"
              type="number"
              min="1"
              step="1"
              placeholder="数字"
            />
            <button class="phase-jump-button" type="submit">表示</button>
          </form>
          <span class="phase-status" id="phaseStatus"></span>
        </div>
        <label class="search-box" for="searchInput">
          <span class="search-label">検索</span>
          <input
            id="searchInput"
            class="search-input"
            type="search"
            placeholder="モンスター名 / 画像URL / A / P"
            autocomplete="off"
          />
        </label>
      </div>

      <section class="reveal">
        <div class="group-grid" id="groupGrid"></div>
      </section>
    </main>

    <script>
      let PHASES = [];

      const GROUP_ORDER = ["S", "A1", "A2"];

      const phaseTabs = document.getElementById("phaseTabs");
      const groupGrid = document.getElementById("groupGrid");
      const searchInput = document.getElementById("searchInput");
      const phaseJumpForm = document.getElementById("phaseJumpForm");
      const phaseJumpInput = document.getElementById("phaseJumpInput");
      const phaseStatus = document.getElementById("phaseStatus");
      let currentPhase = null;
      let currentQuery = "";
      let phaseMeta = [];
      let phaseByNumber = new Map();

      const renderMessage = (text) => {
        groupGrid.innerHTML = "";
        const empty = document.createElement("div");
        empty.className = "empty";
        empty.textContent = text;
        groupGrid.appendChild(empty);
      };

      const loadPhaseMap = async () => {
        try {
          const response = await fetch("./phase_map.json", { cache: "no-store" });
          if (!response.ok) throw new Error(`HTTP ${response.status}`);
          const data = await response.json();
          const phases = Array.isArray(data) ? data : data.phases;
          return Array.isArray(phases) ? phases : [];
        } catch (err) {
          console.warn("phase_map.jsonの読み込みに失敗しました。", err);
          return [];
        }
      };

      const extractPhaseNumber = (phase, fallback) => {
        const sources = [phase?.label, phase?.id, phase?.name];
        for (const source of sources) {
          if (!source) continue;
          const match = String(source).match(/(\d+)/);
          if (match) return parseInt(match[1], 10);
        }
        return fallback;
      };

      const buildPhaseMeta = (phases) => {
        return phases.map((phase, index) => ({
          phase,
          index,
          number: extractPhaseNumber(phase, index + 1),
        }));
      };

      const updatePhaseStatus = (meta, message) => {
        if (!phaseStatus) return;
        if (message) {
          phaseStatus.textContent = message;
          return;
        }
        const label = meta?.phase?.label || meta?.phase?.id || "";
        phaseStatus.textContent = label ? `表示中: ${label}` : "";
      };

      const setActivePhase = (meta) => {
        if (!meta?.phase) return;
        currentPhase = meta.phase;
        renderPhase(currentPhase);
        document.querySelectorAll(".phase-button").forEach((tab) => {
          tab.classList.toggle("is-active", Number(tab.dataset.index) === meta.index);
        });
        updatePhaseStatus(meta);
      };

      const LETTERS = "ABCDEFGHIJKL".split("");

      const buildSchedule = (letters) => {
        if (letters.length < 2) return {};
        const anchor = letters[0];
        const rest = letters.slice(1).reverse();
        const circle = [anchor, ...rest];
        const rounds = letters.length - 1;
        const schedule = {};
        letters.forEach((letter) => {
          schedule[letter] = [];
        });

        let current = circle.slice();
        for (let r = 0; r < rounds; r += 1) {
          for (let i = 0; i < letters.length / 2; i += 1) {
            const left = current[i];
            const right = current[current.length - 1 - i];
            schedule[left].push(right);
            schedule[right].push(left);
          }
          const fixed = current[0];
          const rotating = current.slice(1);
          const last = rotating.pop();
          current = [fixed, last, ...rotating];
        }

        return schedule;
      };

      const SCHEDULE_BY_LETTER = buildSchedule(LETTERS);

      const buildRoundMap = (letters) => {
        const schedule = buildSchedule(letters);
        const roundMap = new Map();
        letters.forEach((letter) => {
          schedule[letter].forEach((opponent, index) => {
            const key = letter < opponent ? `${letter}-${opponent}` : `${opponent}-${letter}`;
            if (!roundMap.has(key)) roundMap.set(key, index + 1);
          });
        });
        return roundMap;
      };

      const ROUND_MAP = buildRoundMap(LETTERS);

      const getMatchLettersFromUrl = (href) => {
        if (!href) return null;
        try {
          const url = new URL(href, location.href);
          const vValue = parseInt(url.searchParams.get("v") || "", 10);
          if (Number.isNaN(vValue)) return null;
          const rowIndex = Math.floor(vValue / 32);
          const colIndex = vValue % 32;
          if (rowIndex < 0 || rowIndex >= LETTERS.length) return null;
          if (colIndex < 0 || colIndex >= LETTERS.length) return null;
          const rowLetter = LETTERS[rowIndex];
          const colLetter = LETTERS[colIndex];
          if (!rowLetter || !colLetter || rowLetter === colLetter) return null;
          return { rowLetter, colLetter };
        } catch (err) {
          return null;
        }
      };

      const getRoundNumberFromUrl = (href) => {
        const match = getMatchLettersFromUrl(href);
        if (!match) return null;
        const key =
          match.rowLetter < match.colLetter
            ? `${match.rowLetter}-${match.colLetter}`
            : `${match.colLetter}-${match.rowLetter}`;
        return ROUND_MAP.get(key) ?? null;
      };

      const parseCsv = (text) => {
        const rows = [];
        let row = [];
        let field = "";
        let inQuotes = false;

        for (let i = 0; i < text.length; i += 1) {
          const char = text[i];
          const next = text[i + 1];

          if (char === '"') {
            if (inQuotes && next === '"') {
              field += '"';
              i += 1;
            } else {
              inQuotes = !inQuotes;
            }
            continue;
          }

          if (!inQuotes && (char === "," || char === "\n" || char === "\r")) {
            if (char === ",") {
              row.push(field);
              field = "";
              continue;
            }

            if (char === "\r" && next === "\n") {
              i += 1;
            }

            row.push(field);
            field = "";
            if (row.some((value) => value.trim() !== "")) {
              rows.push(row);
            }
            row = [];
            continue;
          }

          field += char;
        }

        row.push(field);
        if (row.some((value) => value.trim() !== "")) {
          rows.push(row);
        }
        return rows;
      };

      const rowsToObjects = (rows) => {
        if (!rows.length) return [];
        const headers = rows[0];
        return rows.slice(1).map((row) => {
          const obj = {};
          headers.forEach((header, idx) => {
            obj[header] = row[idx] ?? "";
          });
          return obj;
        });
      };

      const groupByPlayer = (items) => {
        const map = new Map();
        items.forEach((item) => {
          const name = item.player || "(不明)";
          if (!map.has(name)) map.set(name, []);
          map.get(name).push(item);
        });
        return map;
      };

      const normalizeLetter = (value) => {
        if (!value) return "";
        const text = String(value).trim().toUpperCase();
        return LETTERS.includes(text) ? text : "";
      };

      const buildLetterMaps = (items) => {
        const letterToName = new Map();
        const nameToLetter = new Map();
        items.forEach((item) => {
          const letter = normalizeLetter(item.letter);
          const name = item.player || "(不明)";
          if (!letter) return;
          if (!letterToName.has(letter)) letterToName.set(letter, name);
          if (!nameToLetter.has(name)) nameToLetter.set(name, letter);
        });
        return { letterToName, nameToLetter };
      };

      const buildLinks = (row) => {
        const linkKeys = Object.keys(row).filter((key) => key.startsWith("url"));
        return linkKeys.map((key) => row[key]).filter(Boolean);
      };

      const extractMonsterSlug = (imageUrl) => {
        if (!imageUrl) return "";
        const clean = String(imageUrl).split("?")[0];
        const base = clean.split("/").pop() || "";
        const namePart = base.replace(/\.[^.]+$/, "");
        let parts = namePart.split("_");
        if (parts.length && /^\d+$/.test(parts[0])) {
          parts = parts.slice(1);
        }
        if (parts.length && /^\d+g\d+$/i.test(parts[parts.length - 1])) {
          parts = parts.slice(0, -1);
        }
        const slug = parts.join("_").trim();
        return slug || "";
      };

      const buildSkillList = (text) => {
        if (!text) return [];
        return text
          .split("/")
          .map((item) => item.trim())
          .filter(Boolean);
      };

      const setSearch = (value) => {
        currentQuery = value;
        searchInput.value = value;
        if (currentPhase) renderPhase(currentPhase);
      };

      const rowMatchesQuery = (row, query) => {
        if (!query) return true;
        const q = query.toLowerCase();
        const fields = [
          row.monster,
          row.image,
          row["A(アクティブ)"],
          row["P(コンパニオン)"],
        ];
        return fields.some((value) => String(value || "").toLowerCase().includes(q));
      };

      const buildGroupCard = async (groupLabel, csvPath, query) => {
        const card = document.createElement("article");
        card.className = "group-card";

        const header = document.createElement("div");
        header.className = "group-header";

        const title = document.createElement("h3");
        title.className = "group-title";
        title.textContent = groupLabel;

        const actions = document.createElement("div");
        actions.className = "group-actions";

        const download = document.createElement("a");
        download.className = "download-button";
        download.textContent = "CSVダウンロード";
        if (csvPath) {
          download.href = csvPath;
          download.setAttribute("download", "");
        } else {
          download.classList.add("is-disabled");
          download.href = "#";
        }

        actions.append(download);
        header.append(title, actions);
        card.appendChild(header);

        if (!csvPath) {
          const empty = document.createElement("div");
          empty.className = "empty";
          empty.textContent = "CSVが設定されていません。";
          card.appendChild(empty);
          return card;
        }

        try {
          const response = await fetch(csvPath);
          if (!response.ok) throw new Error(`HTTP ${response.status}`);
          const text = await response.text();
          const rows = parseCsv(text);
          const data = rowsToObjects(rows);
          const filtered = query ? data.filter((row) => rowMatchesQuery(row, query)) : data;
          const { letterToName, nameToLetter } = buildLetterMaps(data);
          const hasLetters = letterToName.size > 0;

          if (!data.length) {
            const empty = document.createElement("div");
            empty.className = "empty";
            empty.textContent = "CSVの中身が空です。";
            card.appendChild(empty);
            return card;
          }

          if (!filtered.length) {
            const empty = document.createElement("div");
            empty.className = "empty";
            empty.textContent = "検索条件に一致するデータがありません。";
            card.appendChild(empty);
            return card;
          }

          const players = groupByPlayer(filtered);
          const list = document.createElement("div");
          list.className = "player-list";

          players.forEach((rows, playerName) => {
            const playerCard = document.createElement("div");
            playerCard.className = "player-card";

            const playerHeader = document.createElement("div");
            playerHeader.className = "player-header";

            const nameEl = document.createElement("h4");
            nameEl.className = "player-name";
            nameEl.textContent = playerName;

            playerHeader.append(nameEl);
            playerCard.appendChild(playerHeader);

            const playerLetter = hasLetters ? nameToLetter.get(playerName) || "" : "";
            const schedule = playerLetter ? SCHEDULE_BY_LETTER[playerLetter] || [] : [];

            const table = document.createElement("table");
            const thead = document.createElement("thead");
            thead.innerHTML =
              "<tr>" +
              "<th>モンスター</th>" +
              "<th>Lv</th>" +
              "<th class=\"variant-cell\">種別</th>" +
              "<th class=\"image-cell\">画像</th>" +
              "<th class=\"skill-cell\">A</th>" +
              "<th class=\"skill-cell\">P</th>" +
              "<th class=\"is-toggle\" data-role=\"appear-toggle\">出場数</th>" +
              "</tr>";
            table.appendChild(thead);

            const tbody = document.createElement("tbody");
            rows
              .slice()
              .sort((a, b) => Number(b["出場回数"] || 0) - Number(a["出場回数"] || 0))
              .forEach((row) => {
              const tr = document.createElement("tr");

              const monster = document.createElement("td");
              const monsterSlug = extractMonsterSlug(row.image) || "";
              const monsterLabel = row.monster || "";
              const monsterButton = document.createElement("button");
              monsterButton.type = "button";
              monsterButton.className = "search-link";
              monsterButton.textContent = monsterLabel;
              monsterButton.addEventListener("click", () => {
                if (monsterSlug) {
                  setSearch(monsterSlug);
                } else if (monsterLabel) {
                  setSearch(monsterLabel);
                }
              });
              monster.appendChild(monsterButton);

              const level = document.createElement("td");
              level.textContent = row.level || "";

              const variant = document.createElement("td");
              variant.className = "variant-cell";
              variant.textContent = row.variant || "";

              const imageCell = document.createElement("td");
              imageCell.className = "image-cell";
              if (row.image) {
                const imgButton = document.createElement("button");
                imgButton.type = "button";
                imgButton.className = "image-button";
                imgButton.addEventListener("click", () => {
                  if (monsterSlug) {
                    setSearch(monsterSlug);
                  }
                });
                const img = document.createElement("img");
                img.src = row.image;
                img.alt = row.monster || "";
                imgButton.appendChild(img);
                imageCell.appendChild(imgButton);
              }

              const action = document.createElement("td");
              const actionSkills = buildSkillList(row["A(アクティブ)"]);
              if (actionSkills.length) {
                const list = document.createElement("div");
                list.className = "skill-list";
                actionSkills.forEach((skill) => {
                  const tag = document.createElement("button");
                  tag.type = "button";
                  tag.className = "skill-tag";
                  tag.textContent = skill;
                  tag.addEventListener("click", () => setSearch(skill));
                  list.appendChild(tag);
                });
                action.appendChild(list);
              } else {
                action.textContent = row["A(アクティブ)"] || "";
              }

              const p0 = document.createElement("td");
              const p0Skills = buildSkillList(row["P(コンパニオン)"]);
              if (p0Skills.length) {
                const list = document.createElement("div");
                list.className = "skill-list";
                p0Skills.forEach((skill) => {
                  const tag = document.createElement("button");
                  tag.type = "button";
                  tag.className = "skill-tag";
                  tag.textContent = skill;
                  tag.addEventListener("click", () => setSearch(skill));
                  list.appendChild(tag);
                });
                p0.appendChild(list);
              } else {
                p0.textContent = row["P(コンパニオン)"] || "";
              }

              const appear = document.createElement("td");
              const appearCount = row["出場回数"] || "";
              const links = buildLinks(row);
              if (links.length) {
                const details = document.createElement("details");
                details.className = "appear-toggle";
                const summary = document.createElement("summary");
                summary.textContent = appearCount || String(links.length);
                const linkList = document.createElement("div");
                linkList.className = "link-list";
                links.forEach((href, index) => {
                  const link = document.createElement("a");
                  link.href = href;
                  link.target = "_blank";
                  link.rel = "noopener";
                  const match = getMatchLettersFromUrl(href);
                  const roundNumber = getRoundNumberFromUrl(href);
                  let label = roundNumber ? `${roundNumber}戦目` : `リンク${index + 1}`;
                  if (
                    hasLetters &&
                    match &&
                    playerLetter &&
                    (match.rowLetter === playerLetter || match.colLetter === playerLetter)
                  ) {
                    const opponentLetter =
                      match.rowLetter === playerLetter ? match.colLetter : match.rowLetter;
                    const opponentName = letterToName.get(opponentLetter) || opponentLetter;
                    const roundIndex = schedule.indexOf(opponentLetter);
                    if (roundIndex >= 0 && opponentName) {
                      label = `${roundIndex + 1}.${opponentName}戦`;
                    }
                  }
                  link.textContent = label;
                  linkList.appendChild(link);
                });
                details.append(summary, linkList);
                appear.appendChild(details);
              } else {
                appear.textContent = appearCount;
              }

              tr.append(monster, level, variant, imageCell, action, p0, appear);
              tbody.appendChild(tr);
            });

            table.appendChild(tbody);

            const toggleHeader = table.querySelector("th[data-role=\"appear-toggle\"]");
            if (toggleHeader) {
              toggleHeader.addEventListener("click", () => {
                const detailsList = table.querySelectorAll("details.appear-toggle");
                if (!detailsList.length) return;
                const shouldOpen = Array.from(detailsList).some((detail) => !detail.open);
                detailsList.forEach((detail) => {
                  detail.open = shouldOpen;
                });
              });
            }
            playerCard.appendChild(table);
            list.appendChild(playerCard);
          });

          card.appendChild(list);
        } catch (err) {
          const empty = document.createElement("div");
          empty.className = "empty";
          empty.textContent = "CSVが見つかりません。ファイル名とパスを確認してください。";
          card.appendChild(empty);
        }

        return card;
      };

      const renderPhase = async (phase) => {
        if (!phase || !phase.groups) {
          renderMessage("期の設定が不正です。phase_map.json を確認してください。");
          return;
        }
        groupGrid.innerHTML = "";
        for (const group of GROUP_ORDER) {
          const card = await buildGroupCard(group, phase.groups[group], currentQuery);
          groupGrid.appendChild(card);
        }
      };

      const setupTabs = () => {
        phaseTabs.innerHTML = "";
        if (!PHASES.length) {
          renderMessage("期の設定がありません。phase_map.json を確認してください。");
          return;
        }
        phaseMeta = buildPhaseMeta(PHASES);
        phaseByNumber = new Map();
        phaseMeta.forEach((meta) => {
          if (meta.number != null) phaseByNumber.set(meta.number, meta);
        });
        const latestTwo = phaseMeta
          .slice()
          .sort((a, b) => b.number - a.number || b.index - a.index)
          .slice(0, 2);

        latestTwo.forEach((meta) => {
          const button = document.createElement("button");
          button.type = "button";
          button.className = "phase-button";
          button.textContent = meta.phase.label;
          button.dataset.index = String(meta.index);
          button.addEventListener("click", () => {
            setActivePhase(meta);
          });
          phaseTabs.appendChild(button);
        });

        const latestMeta = latestTwo[0] || phaseMeta[0];
        if (latestMeta) setActivePhase(latestMeta);
      };

      searchInput.addEventListener("input", (event) => {
        currentQuery = event.target.value.trim();
        if (currentPhase) renderPhase(currentPhase);
      });

      if (phaseJumpForm) {
        phaseJumpForm.addEventListener("submit", (event) => {
          event.preventDefault();
          const value = parseInt(phaseJumpInput?.value || "", 10);
          if (Number.isNaN(value)) {
            updatePhaseStatus(null, "期の数字を入力してください");
            return;
          }
          const meta = phaseByNumber.get(value);
          if (!meta) {
            updatePhaseStatus(null, `${value}期は未登録です`);
            return;
          }
          setActivePhase(meta);
        });
      }

      const init = async () => {
        PHASES = await loadPhaseMap();
        setupTabs();
      };

      init();
    </script>
  </body>
</html>
